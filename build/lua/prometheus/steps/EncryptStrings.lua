-- This Script is Part of the Prometheus Obfuscator by Levno_710
--
-- EncryptStrings.lua
--
-- This Step provides a Simple Obfuscation Step that encrypts strings

local Step          = require("prometheus.step")
local Ast           = require("prometheus.ast")
local Scope         = require("prometheus.scope")
local RandomStrings = require("prometheus.randomStrings")
local Parser        = require("prometheus.parser")
local Enums         = require("prometheus.enums")
local logger        = require("logger")
local visitast      = require("prometheus.visitast")
local util          = require("prometheus.util")

local AstKind       = Ast.AstKind

local floor         = math.floor
local random        = math.random
local str_byte      = string.byte
local str_char      = string.char
local str_len       = string.len
local tbl_concat    = table.concat
local tbl_remove    = table.remove

local EncryptStrings = Step:extend()
EncryptStrings.Description = "This Step will encrypt strings within your Program."
EncryptStrings.Name        = "Encrypt Strings"

-- No settings (for now), but kept for future extension
EncryptStrings.SettingsDescriptor = {}

function EncryptStrings:init(settings)
	-- Intentionally left blank; hook for future options
end

---------------------------------------------------------------------
-- Encryption Service
---------------------------------------------------------------------

function EncryptStrings:CreateEncryptionService()
	-- Track seeds to avoid collisions (so each encrypted string is keyed uniquely)
	local usedSeeds = {}

	-- Secret keys:
	--  6-bit, 7-bit, 44-bit, and 8-bit integers used to parameterize the PRNG
	local secret_key_6  = random(0, 63)                -- 6-bit  arbitrary integer (0..63)
	local secret_key_7  = random(0, 127)               -- 7-bit  arbitrary integer (0..127)
	local secret_key_44 = random(0, 17592186044415)    -- 44-bit arbitrary integer (0..17592186044415)
	local secret_key_8  = random(0, 255)               -- 8-bit  arbitrary integer (0..255)

	-- 257 is prime, so this generates a primitive root mod 257 based on an index
	local function primitive_root_257(idx)
		local g, m, d = 1, 128, 2 * idx + 1
		repeat
			g, m, d = g * g * (d >= m and 3 or 1) % 257, m / 2, d % m
		until m < 1
		return g
	end

	-- PRNG parameters (kept same for deterministic compatibility)
	local param_mul_8  = primitive_root_257(secret_key_7)
	local param_mul_45 = secret_key_6 * 4 + 1
	local param_add_45 = secret_key_44 * 2 + 1

	-- Internal PRNG state
	local state_45 = 0
	local state_8  = 2

	-- Buffer of bytes from the last 32-bit random value
	local prev_values = {}

	local function set_seed(seed_53)
		state_45     = seed_53 % 35184372088832
		state_8      = seed_53 % 255 + 2
		prev_values  = {}
	end

	local function gen_seed()
		local seed
		repeat
			seed = random(0, 35184372088832)
		until not usedSeeds[seed]
		usedSeeds[seed] = true
		return seed
	end

	local function get_random_32()
		-- 45-bit LCG
		state_45 = (state_45 * param_mul_45 + param_add_45) % 35184372088832

		-- 8-bit multiplicative generator mod 257
		repeat
			state_8 = state_8 * param_mul_8 % 257
		until state_8 ~= 1

		local r = state_8 % 32
		local n = floor(state_45 / 2 ^ (13 - (state_8 - r) / 32)) % 2 ^ 32 / 2 ^ r
		return floor(n % 1 * 2 ^ 32) + floor(n)
	end

	local function get_next_pseudo_random_byte()
		if #prev_values == 0 then
			local rnd    = get_random_32() -- value 0..4294967295
			local low_16 = rnd % 65536
			local high_16 = (rnd - low_16) / 65536

			local b1 = low_16 % 256
			local b2 = (low_16 - b1) / 256
			local b3 = high_16 % 256
			local b4 = (high_16 - b3) / 256

			prev_values = { b1, b2, b3, b4 }
		end

		return tbl_remove(prev_values)
	end

	-- Encrypts a plain Lua string to an encoded string + a per-string seed
	local function encrypt(str)
		local seed = gen_seed()
		set_seed(seed)

		local len = str_len(str)
		local out = {}

		local prevVal = secret_key_8
		for i = 1, len do
			local byte = str_byte(str, i)
			out[i] = str_char((byte - (get_next_pseudo_random_byte() + prevVal)) % 256)
			prevVal = byte
		end

		return tbl_concat(out), seed
	end

	-----------------------------------------------------------------
	-- Code generator for decryption stub
	-----------------------------------------------------------------
	local function genCode()
		-- NOTE:
		--  - param_mul_45, param_add_45, param_mul_8 and secret_key_8 are baked in
		--  - This stub creates STRINGS (a proxy table) and DECRYPT (the resolver)
		--  - The main AST then rewires these to locals for better encapsulation
		local code = [[
do
	local floor  = math.floor
	local random = math.random
	local remove = table.remove
	local char   = string.char

	local state_45 = 0
	local state_8  = 2

	-- Build an identity charmap in randomized key order to confuse static analysis.
	-- For every n in 1..256, charmap[n] = char(n - 1) exactly once.
	local charmap = {}
	do
		local nums = {}
		for i = 1, 256 do
			nums[i] = i
		end

		while #nums > 0 do
			local idx = random(1, #nums)
			local n   = remove(nums, idx)
			charmap[n] = char(n - 1)
		end
	end

	-- 32-bit PRNG output split into 4 bytes (same generator as in the encrypt side)
	local prev_values = {}
	local function get_next_pseudo_random_byte()
		if #prev_values == 0 then
			state_45 = (state_45 * ]] .. tostring(param_mul_45) .. [[ + ]] .. tostring(param_add_45) .. [[) % 35184372088832
			repeat
				state_8 = state_8 * ]] .. tostring(param_mul_8) .. [[ % 257
			until state_8 ~= 1

			local r = state_8 % 32
			local n = floor(state_45 / 2 ^ (13 - (state_8 - r) / 32)) % 2 ^ 32 / 2 ^ r
			local rnd = floor(n % 1 * 2 ^ 32) + floor(n)

			local low_16  = rnd % 65536
			local high_16 = (rnd - low_16) / 65536

			local b1 = low_16 % 256
			local b2 = (low_16 - b1) / 256
			local b3 = high_16 % 256
			local b4 = (high_16 - b3) / 256
			prev_values = { b1, b2, b3, b4 }
		end

		return table.remove(prev_values)
	end

	-- backing table for decoded strings, keyed by seed
	local realStrings = {}

	-- Proxy exposed to user code (STRINGS[DECRYPT("...")])
	STRINGS = setmetatable({}, {
		__index     = realStrings,
		__metatable = nil,
	})

	function DECRYPT(str, seed)
		local realStringsLocal = realStrings
		if not realStringsLocal[seed] then
			prev_values = {}

			local chars = charmap
			state_45    = seed % 35184372088832
			state_8     = seed % 255 + 2

			local len = string.len(str)
			local prevVal = ]] .. tostring(secret_key_8) .. [[

			local out = {}
			for i = 1, len do
				prevVal = (string.byte(str, i) + get_next_pseudo_random_byte() + prevVal) % 256
				out[i]  = chars[prevVal + 1]
			end

			realStringsLocal[seed] = table.concat(out)
		end

		-- Important: DECRYPT returns the seed, not the string.
		-- User code reads STRINGS[DECRYPT(...)] to get the actual value.
		return seed
	end
end]]

		return code
	end

	return {
		encrypt       = encrypt,
		param_mul_45  = param_mul_45,
		param_mul_8   = param_mul_8,
		param_add_45  = param_add_45,
		secret_key_8  = secret_key_8,
		genCode       = genCode,
	}
end

---------------------------------------------------------------------
-- AST Integration
---------------------------------------------------------------------

function EncryptStrings:apply(ast, pipeline)
	local Encryptor = self:CreateEncryptionService()

	-- Parse generated decryption stub
	local code   = Encryptor.genCode()
	local parser = Parser:new({ LuaVersion = Enums.LuaVersion.Lua51 })
	local newAst = parser:parse(code)

	-- The generated stub is wrapped in a single top-level do-statement
	local doStat = newAst.body.statements[1]

	local scope       = ast.body.scope
	local decryptVar  = scope:addVariable()
	local stringsVar  = scope:addVariable()

	-- Make sure the stub's scope is parented to the main body scope
	doStat.body.scope:setParent(scope)

	-----------------------------------------------------------------
	-- Rewire STRINGS / DECRYPT in the generated stub so they refer
	-- to the locals `stringsVar` / `decryptVar` in the main scope.
	-----------------------------------------------------------------
	visitast(newAst, nil, function(node, data)
		if node.kind == AstKind.FunctionDeclaration then
			if node.scope:getVariableName(node.id) == "DECRYPT" then
				data.scope:removeReferenceToHigherScope(node.scope, node.id)
				data.scope:addReferenceToHigherScope(scope, decryptVar)
				node.scope = scope
				node.id    = decryptVar
			end
		end

		if node.kind == AstKind.AssignmentVariable or node.kind == AstKind.VariableExpression then
			if node.scope:getVariableName(node.id) == "STRINGS" then
				data.scope:removeReferenceToHigherScope(node.scope, node.id)
				data.scope:addReferenceToHigherScope(scope, stringsVar)
				node.scope = scope
				node.id    = stringsVar
			end
		end
	end)

	-----------------------------------------------------------------
	-- Replace all string literals with:
	--   STRINGS[DECRYPT("<encrypted>", <seed>)]
	-----------------------------------------------------------------
	visitast(ast, nil, function(node, data)
		if node.kind == AstKind.StringExpression then
			data.scope:addReferenceToHigherScope(scope, stringsVar)
			data.scope:addReferenceToHigherScope(scope, decryptVar)

			local encrypted, seed = Encryptor.encrypt(node.value)

			return Ast.IndexExpression(
				Ast.VariableExpression(scope, stringsVar),
				Ast.FunctionCallExpression(
					Ast.VariableExpression(scope, decryptVar),
					{
						Ast.StringExpression(encrypted),
						Ast.NumberExpression(seed),
					}
				)
			)
		end
	end)

	-----------------------------------------------------------------
	-- Insert stub and locals into the main AST
	-----------------------------------------------------------------
	table.insert(ast.body.statements, 1, doStat)
	table.insert(ast.body.statements, 1,
		Ast.LocalVariableDeclaration(
			scope,
			util.shuffle { decryptVar, stringsVar },
			{}
		)
	)

	return ast
end

return EncryptStrings
